---
title: 'Feb 2023 Daily Leetcode: Leetcode in C++'
date: '2023-02-01'
---

# 48. Sort List

- Difficulty: Medium
- Link: [48. Sort List](https://leetcode.com/problems/sort-list/)

## Description

Given the `head` of a linked list, return the list after sorting it in ascending order.

## Solution

Merge sort is constantly used when it comes to sort a linked list. This question also appears in my algorithm course's final exam.

- Runtime: `O(nlgn)`
- Space: `O(lgn)` - O(lgn) is the call graph

~~~cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        // empty list or only one element
        if(!head||!head->next) 
            return head;
        ListNode* mid = split(head);
        ListNode* left = sortList(head);
        ListNode* right = sortList(mid);
        
        return merge(left,right);
    }
    
    // famous two finger algorithm
    ListNode* merge(ListNode* f1, ListNode* f2){
        ListNode* sentinel = new ListNode(0);
        ListNode* it = sentinel;
        
        while(f1&&f2){
            if(f1->val < f2->val) {
                it->next = f1;
                f1 = f1->next;
            }
            else{
                it->next = f2;
                f2 = f2->next;
            }
            it = it->next;
        }
        
        while(f1){
            it->next = f1;
            f1 = f1->next;
            it = it->next;
        }
        
        while(f2){
            it->next = f2;
            f2 = f2->next;
            it = it->next;
        }
        
        return sentinel->next;
    }
    
    ListNode* split(ListNode* head) {
        ListNode *midPrev = nullptr;
        while(head && head->next) {
            midPrev = (midPrev == nullptr) ? head : midPrev->next;
            head = head->next->next;
        }
        ListNode* mid = midPrev->next;
        // detach the linked list into two halves
        midPrev->next = nullptr;
        
        // return the second half, i.e, the detached
        return mid;
    }
};
~~~