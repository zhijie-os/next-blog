---
title: 'Feb 2023 Daily Leetcode: Leetcode in C++'
date: '2023-02-01'
---

# 48. Sort List

- Difficulty: Medium
- Link: [48. Sort List](https://leetcode.com/problems/sort-list/)

## Description

Given the `head` of a linked list, return the list after sorting it in ascending order.

## Solution

Merge sort is constantly used when it comes to sort a linked list. This question also appears in my algorithm course's final exam.

- Runtime: `O(nlgn)`
- Space: `O(lgn)` - O(lgn) is the call graph

~~~cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        // empty list or only one element
        if(!head||!head->next) 
            return head;
        ListNode* mid = split(head);
        ListNode* left = sortList(head);
        ListNode* right = sortList(mid);
        
        return merge(left,right);
    }
    
    // famous two finger algorithm
    ListNode* merge(ListNode* f1, ListNode* f2){
        ListNode* sentinel = new ListNode(0);
        ListNode* it = sentinel;
        
        while(f1&&f2){
            if(f1->val < f2->val) {
                it->next = f1;
                f1 = f1->next;
            }
            else{
                it->next = f2;
                f2 = f2->next;
            }
            it = it->next;
        }
        
        while(f1){
            it->next = f1;
            f1 = f1->next;
            it = it->next;
        }
        
        while(f2){
            it->next = f2;
            f2 = f2->next;
            it = it->next;
        }
        
        return sentinel->next;
    }
    
    ListNode* split(ListNode* head) {
        ListNode *midPrev = nullptr;
        while(head && head->next) {
            midPrev = (midPrev == nullptr) ? head : midPrev->next;
            head = head->next->next;
        }
        ListNode* mid = midPrev->next;
        // detach the linked list into two halves
        midPrev->next = nullptr;
        
        // return the second half, i.e, the detached
        return mid;
    }
};
~~~


# 2131. Longest Palindrome by Concatenating Two Letter Words

- Difficulty: Medium
- Link: [48. Sort List](https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/)



## Description

You are given an array of strings `words`. Each element of `words` consists of two lowercase English letters.

Create the longest possible palindrome by selecting some elements from `words` and concatenating them in any order. Each element can be selected at most once.

Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return `0`.

A palindrome is a string that reads the same forward and backward.

## Solution 

- Runtime: `O(n)`
- Space: `O(n)` 

~~~cpp
class Solution {
public:
    int longestPalindrome(vector<string>& words) {
        unordered_map<string, int> table;
        int result = 0;
        for(auto str: words){
            string rev(1,str[1]);
            rev+=str[0];
            if(table[rev]>0){
                table[rev]-=1;
                result+=4;
            }
            else{
                table[str]+=1;
            }
        }
        for(auto it:table){
            if(it.second>0&&it.first[0]==it.first[1]){
                result+=2;
                return result;
            }
        }
        
        return result;
    }
};
~~~