---
title: 'September 2023 Daily Leetcode: Grind 75 in Python'
date: '2023-09-11'
---
# Introduction

I have attended [CodeWeekend](https://www.meetup.com/codeweekendgroup/events/295430998/) and meet
many interesting friends there. We have challenged ourselves to

- Solve one LeetCode problem per day.
- Read 50 pages per week of Cracking the Coding Interview and after finishing it, continue with the System Design Interview (volume 1 and 2) books.

So anyways, I am back to leetcode!

# 2023-09-10
## 20. Valid Parentheses

~~~python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s:
            if c == '(' or c == '{' or c == '[':
                stack.append(c)
            else:
                if len(stack) == 0:
                    return False
                if c == ')':
                    last = stack.pop()
                    if last != '(':
                        return False
                if c == '}':
                    last = stack.pop()
                    if last != '{':
                        return False
                if c == ']':
                    last = stack.pop()
                    if last != '[':
                        return False
        if len(stack) > 0:
            return False
        return True
~~~

## 21. Merge Two Sorted Lists

~~~python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:

        sentinel = ListNode()
        head = sentinel
        while list1 and list2:
            if list1.val < list2.val:
                head.next = list1
                list1 = list1.next
            else:
                head.next = list2
                list2 = list2.next
            head = head.next
        
        while list1:
            head.next = list1
            list1 = list1.next
            head = head.next
        
        while list2:
            head.next = list2
            list2 = list2.next
            head = head.next
        
        return sentinel.next
~~~

# 2023-09-11
## 121. Best Time to Buy and Sell Stock

~~~python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # naive solution would require O(n^2)
        # how we can do better? Likely a greedy algorithm would help
        # if it is a greedy, how can we find the local optimal solution?
        # a new optimal would either: a new higher, or a new lower
        low = prices[0]
        opt = 0

        for p in prices:
            # potiential new lowest
            if p < low:
                low = p
            else: 
                # potiential new high
                opt = max(p - low, opt)
        
        return opt
~~~


## 125. Valid Palindrome

~~~python
class Solution:
    def alphanumeric(self, c) -> bool:
        return  (ord(c) <= 57 and ord(c)>=48) or (ord(c) >= 65 and ord(c)<=90) or(ord(c) >= 97 and ord(c) <= 122)

    def isPalindrome(self, s: str) -> bool:
        s = s.lower()
        ptr1=0
        ptr2=len(s)-1

        while ptr1<ptr2:
            if not self.alphanumeric(s[ptr1]):
                ptr1 += 1
                continue
            if not self.alphanumeric(s[ptr2]):
                ptr2 -= 1
                continue
            if s[ptr1] != s[ptr2]:
                return False
            else:
                ptr1 += 1
                ptr2 -= 1
        
        return True
~~~


# 2023-09-12

## 226. Invert Binary Tree

~~~python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        else:
            right = self.invertTree(root.left)
            left = self.invertTree(root.right)
            root.left = left
            root.right = right
            return root
~~~

## 242. Valid Anagram

~~~python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        count_table = [0]*26
        for s_c in s:
            count_table[ord(s_c)-97] += 1
        
        for t_c in t:
            if count_table[ord(t_c)-97] == 0:
                return False
            else:
                count_table[ord(t_c)-97] -= 1
        
        return True
~~~


# 09-13
## 704. Binary Search


~~~python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # two pointer binary search is cooler
        left = 0
        right = len(nums) - 1
        while left <= right:
            mid = math.floor((left + right) / 2)
            if target > nums[mid]:
                left = mid + 1
            elif target < nums[mid]:
                right = mid - 1
            else:
                return mid
        
        return -1
~~~


## 733. Flood Fill

~~~python
# DFS implementation
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        visited = [[False for x in range(len(image[0]))] for y in range(len(image))]
        stack = [(sr,sc)]
        probe = image[sr][sc]
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while len(stack) > 0:
            curr = stack.pop()
            visited[curr[0]][curr[1]] = True
            if image[curr[0]][curr[1]] == probe:
                image[curr[0]][curr[1]] = color 
                # new tasks
                for d in dirs:
                    sr = curr[0] + d[0]
                    sc = curr[1] + d[1]
                    if sr>=0 and sr<len(image) and sc>=0 and sc<len(image[0]):
                        if not visited[sr][sc]:
                            stack.append((sr,sc))
        return image
~~~